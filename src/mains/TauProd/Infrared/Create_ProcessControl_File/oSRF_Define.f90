!
! oSRF_Define
!
! Module defining the oSRF object.
!
!
! CREATION HISTORY:
!   Written by:     Paul van Delst, 22-Jul-2009
!                       paul.vandelst@noaa.gov

MODULE oSRF_Define

  ! -----------------
  ! Environment setup
  ! -----------------
  ! Module use
  USE Type_Kinds               , ONLY: fp
  USE Message_Handler          , ONLY: SUCCESS, FAILURE, WARNING, Display_Message
  USE Compare_Float_Numbers    , ONLY: DEFAULT_N_SIGFIG, &
                                       OPERATOR(.EqualTo.), &
                                       Compares_Within_Tolerance
  USE Integrate_Utility        , ONLY: Integral
  USE SensorInfo_Parameters    , ONLY: INVALID_WMO_SATELLITE_ID, &
                                       INVALID_WMO_SENSOR_ID   , &
                                       N_SENSOR_TYPES          , &
                                       INVALID_SENSOR          , &
                                       MICROWAVE_SENSOR        , &
                                       INFRARED_SENSOR         , &
                                       VISIBLE_SENSOR          , &
                                       ULTRAVIOLET_SENSOR      , &
                                       SENSOR_TYPE_NAME
  USE PtrArr_Define            , ONLY: PtrArr_type      , &
                                       OPERATOR(==)     , &
                                       PtrArr_Associated, &
                                       PtrArr_Destroy   , &
                                       PtrArr_Create    , &
                                       PtrArr_SetValue  , &
                                       PtrArr_GetValue  , &
                                       PtrArr_Inspect   , &
                                       PtrArr_ErrMsg
  USE Planck_Functions         , ONLY: Planck_Temperature, &
                                       Planck_Radiance
  USE Fundamental_Constants    , ONLY: C_1, &
                                       C_2
  USE Spectral_Units_Conversion, ONLY: GHz_to_inverse_cm, &
                                       micron_to_inverse_cm
  USE oSRF_Parameters
  ! Disable implicit typing
  IMPLICIT NONE


  ! ------------
  ! Visibilities
  ! ------------
  ! Everything private by default
  PRIVATE
  ! Operators
  PUBLIC:: OPERATOR(==)
  ! Derived type definitions
  PUBLIC:: oSRF_type
  ! Parameters
  PUBLIC:: OSRF_RELEASE
  PUBLIC:: OSRF_VERSION
!  PUBLIC:: INVALID_WMO_SATELLITE_ID
!  PUBLIC:: INVALID_WMO_SENSOR_ID
!  PUBLIC:: N_SENSOR_TYPES
!  PUBLIC:: INVALID_SENSOR
!  PUBLIC:: MICROWAVE_SENSOR
!  PUBLIC:: INFRARED_SENSOR
!  PUBLIC:: VISIBLE_SENSOR
!  PUBLIC:: ULTRAVIOLET_SENSOR
!  PUBLIC:: SENSOR_TYPE_NAME
  ! Procedures
  PUBLIC:: oSRF_Associated
  PUBLIC:: oSRF_Destroy
  PUBLIC:: oSRF_Create
  PUBLIC:: oSRF_SetValue
  PUBLIC:: oSRF_GetValue
  PUBLIC:: oSRF_Inspect
  PUBLIC:: oSRF_Info
  PUBLIC:: oSRF_Integrate
  PUBLIC:: oSRF_Central_Frequency
  PUBLIC:: oSRF_Polychromatic_Coefficients
  PUBLIC:: oSRF_Planck_Coefficients
  PUBLIC:: oSRF_Convolve
  PUBLIC:: oSRF_DefineVersion
  PUBLIC:: oSRF_Compare
  ! ...Flag specific procedures. Include file auto-generated by gen_flag_procedures.rb
  INCLUDE 'oSRF_Flag_Visibilities.inc'
  ! ...Sensor specific procedures. Include file auto-generated by gen_sensor_procedures.rb
  INCLUDE 'oSRF_Sensor_Visibilities.inc'



  ! -------------------
  ! Procedure overloads
  ! -------------------
  INTERFACE OPERATOR(==)
    MODULE PROCEDURE oSRF_Equal
  END INTERFACE OPERATOR(==)


  ! -----------------
  ! Module parameters
  ! -----------------
  CHARACTER(*), PARAMETER:: MODULE_VERSION_ID = &
    '$Id: oSRF_Define.f90 45707 2014-09-16 18:31:42Z paul.vandelst@noaa.gov $'
  ! String lengths
  INTEGER,  PARAMETER:: ML = 256  ! Message length
  INTEGER,  PARAMETER:: SL = 30  ! Sensor Id length
  ! Keyword set value
  INTEGER,  PARAMETER:: SET = 1
  ! Literal constants
  REAL(fp), PARAMETER:: ZERO = 0.0_fp
  REAL(fp), PARAMETER:: ONE  = 1.0_fp
  ! Current valid release and version numbers
  INTEGER, PARAMETER:: OSRF_RELEASE = 2  ! This determines structure and file formats.
  INTEGER, PARAMETER:: OSRF_VERSION = 1  ! This is just the data version.


  ! --------------------------
  ! oSRF data type definitions
  ! --------------------------
  TYPE:: oSRF_type
    ! Release and version information
    INTEGER:: Release = OSRF_RELEASE
    INTEGER:: Version = OSRF_VERSION
    ! Allocation indicator
    LOGICAL:: Is_Allocated = .FALSE.
    ! Dimension values
    INTEGER:: n_Bands = 0  ! nB
    ! ...Pseudo-fixed dimensions
    INTEGER:: n_Temperatures         = 0  ! I
    INTEGER:: n_Polychromatic_Coeffs = 0  ! J
    ! Scalar components
    CHARACTER(SL):: Sensor_ID = ''
    INTEGER  :: WMO_Satellite_Id = INVALID_WMO_SATELLITE_ID
    INTEGER  :: WMO_Sensor_Id    = INVALID_WMO_SENSOR_ID
    INTEGER  :: Sensor_Type      = INVALID_SENSOR
    INTEGER  :: Channel  = 0
    REAL(fp):: Integral = ZERO
    INTEGER  :: Flags    = 0
    REAL(fp):: f0       = ZERO
    ! Coefficient data
    REAL(fp)              :: Planck_Coeffs(N_PLANCK_COEFFS) = ZERO
    REAL(fp), ALLOCATABLE:: Polychromatic_Coeffs(:)
    ! Response data
    INTEGER,           ALLOCATABLE:: n_Points(:)  ! nB
    REAL(fp),          ALLOCATABLE:: f1(:)        ! nB [GHz]
    REAL(fp),          ALLOCATABLE:: f2(:)        ! nB [GHz]
    TYPE(PtrArr_type), ALLOCATABLE:: Frequency(:)  ! nB [GHz]
    TYPE(PtrArr_type), ALLOCATABLE:: Response(:)  ! nB [-]
    ! Temperature data
    REAL(fp), ALLOCATABLE:: Temperature(:)            ! I
    REAL(fp), ALLOCATABLE:: Effective_Temperature(:)  ! I
    REAL(fp), ALLOCATABLE:: Fit_Temperature(:)        ! I
  END TYPE oSRF_type


CONTAINS


!################################################################################
!################################################################################
!##                                                                            ##
!##                         ## PUBLIC MODULE ROUTINES ##                       ##
!##                                                                            ##
!################################################################################
!################################################################################

!--------------------------------------------------------------------------------
!:sdoc+:
!
! NAME:
!   oSRF_Associated
!
! PURPOSE:
!   Elemental function to test the status of the allocatable components
!   of an oSRF object.
!
! CALLING SEQUENCE:
!   Status = oSRF_Associated( oSRF )
!
! OBJECT:
!   oSRF:    oSRF structure which is to have its member's
!            status tested.
!            UNITS:      N/A
!            TYPE:       TYPE(oSRF_type)
!            DIMENSION:  Scalar
!            ATTRIBUTES: INTENT(IN)
!
! FUNCTION RESULT:
!   Status:  The return value is a logical value indicating the
!            status of the oSRF members.
!            .TRUE.  - if ANY of the oSRF allocatable or
!                      pointer members are in use.
!            .FALSE. - if ALL of the oSRF allocatable or
!                      pointer members are not in use.
!            UNITS:      N/A
!            TYPE:       LOGICAL
!            DIMENSION:  Scalar
!
!:sdoc-:
!--------------------------------------------------------------------------------

  ELEMENTAL FUNCTION oSRF_Associated(self) RESULT(alloc_status)
    TYPE(oSRF_type), INTENT(IN):: self
    LOGICAL:: alloc_status
    alloc_status = self%Is_Allocated
  END FUNCTION oSRF_Associated



!------------------------------------------------------------------------------
!:sdoc+:
!
! NAME:
!   oSRF_Destroy
!
! PURPOSE:
!   Elemental subroutine to re-initialize oSRF objects.
!
! CALLING SEQUENCE:
!   CALL oSRF_Destroy( oSRF )
!
! OBJECT:
!   oSRF:  Re-initialised oSRF structure.
!          UNITS:      N/A
!          TYPE:       TYPE(oSRF_type)
!          DIMENSION:  Scalar
!          ATTRIBUTES: INTENT(OUT)
!
!:sdoc-:
!------------------------------------------------------------------------------

  ELEMENTAL SUBROUTINE oSRF_Destroy(self)
    TYPE(oSRF_type), INTENT(OUT):: self
    self%Is_Allocated = .FALSE.
  END SUBROUTINE oSRF_Destroy


!------------------------------------------------------------------------------
!:sdoc+:
!
! NAME:
!   oSRF_Create
!
! PURPOSE:
!   Elemental subroutine to create an instance of the oSRF object.
!
! CALLING SEQUENCE:
!   CALL oSRF_Create( &
!          oSRF, &
!          n_Bands, &
!          n_Temperatures               = n_temperatures              , &
!          n_Polychromatic_Coefficients = n_polychromatic_coefficients  )
!
! OBJECT:
!   oSRF:         oSRF object.
!                 UNITS:      N/A
!                 TYPE:       TYPE(oSRF_type)
!                 DIMENSION:  Scalar
!                 ATTRIBUTES: INTENT(OUT)
!
! INPUTS:
!   n_Bands:      The number of passbands in the SRF.
!                 Only values of 1, 2, or 4 are valid.
!                 UNITS:      N/A
!                 TYPE:       INTEGER
!                 DIMENSION:  Scalar
!                 ATTRIBUTES: INTENT(IN)
!
! OPTIONAL INPUTS:
!   n_Temperatures:         The number of temperatures used to generate the
!                           polychromatic correction coefficients.
!                           Default is determined by settings in the 
!                           oSRF_Parameters module.
!                           UNITS:      N/A
!                           TYPE:       INTEGER
!                           DIMENSION:  Scalar
!                           ATTRIBUTES: INTENT(IN), OPTIONAL
!
!   n_Polychromatic_Coeffs: The number of polychromatic correction
!                           coefficients generated during processing.
!                           Default is determined by settings in the 
!                           oSRF_Parameters module.
!                           UNITS:      N/A
!                           TYPE:       INTEGER
!                           DIMENSION:  Scalar
!                           ATTRIBUTES: INTENT(IN), OPTIONAL
!
!:sdoc-:
!------------------------------------------------------------------------------

  ELEMENTAL SUBROUTINE oSRF_Create( &
    self                  , &
    n_Bands               , &
    n_Temperatures        , &
    n_Polychromatic_Coeffs  )
    ! Arguments
    TYPE(oSRF_type),   INTENT(OUT):: self
    INTEGER,           INTENT(IN)  :: n_Bands
    INTEGER, OPTIONAL, INTENT(IN)  :: n_Temperatures
    INTEGER, OPTIONAL, INTENT(IN)  :: n_Polychromatic_Coeffs
    ! Local variables
    INTEGER:: alloc_stat
    INTEGER:: n_t, n_pc

    ! Check input
    IF ( n_Bands /= 1 .AND. n_Bands /= 2 .AND. n_Bands /= 4 ) RETURN
    ! ...Optional inputs
    n_t = N_TEMPS
    IF ( PRESENT(n_Temperatures) ) n_t = n_Temperatures
    n_pc = N_POLY_COEFFS
    IF ( PRESENT(n_Polychromatic_Coeffs) ) n_pc = n_Polychromatic_Coeffs


    ! Perform the main array allocations
    ALLOCATE( self%n_Points( n_bands ), &
              self%f1( n_bands )       , &
              self%f2( n_bands )       , &
              self%Frequency( n_bands ), &
              self%Response( n_bands ), &
              self%Temperature( n_t )          , &
              self%Effective_Temperature( n_t ), &
              self%Fit_Temperature( n_t )      , &
              self%Polychromatic_Coeffs( n_pc ), &
              STAT = alloc_stat )
    IF ( alloc_stat /= 0 ) RETURN


    ! Assign the band dimension and initialise arrays
    self%n_Bands = n_bands
    self%n_Temperatures         = n_t
    self%n_Polychromatic_Coeffs = n_pc
    self%n_Points = 0
    self%f1 = ZERO
    self%f2 = ZERO
    self%Polychromatic_Coeffs  = ZERO
    self%Temperature           = ZERO
    self%Effective_Temperature = ZERO
    self%Fit_Temperature       = ZERO


    ! Set the allocation flag
    self%Is_Allocated = .TRUE.

  END SUBROUTINE oSRF_Create


!--------------------------------------------------------------------------------
!:sdoc+:
!
! NAME:
!   oSRF_SetValue
!
! PURPOSE:
!   Function to set the value of an oSRF object component.
!
! CALLING SEQUENCE:
!   Error_Status = oSRF_SetValue( &
!                    oSRF                                         , &
!                    Band                  = Band                 , &
!                    Version               = Version              , &
!                    Sensor_Id             = Sensor_Id            , &
!                    WMO_Satellite_Id      = WMO_Satellite_Id     , &
!                    WMO_Sensor_Id         = WMO_Sensor_Id        , &
!                    Sensor_Type           = Sensor_Type          , &
!                    Channel               = Channel              , &
!                    Integral              = Integral             , &
!                    Flags                 = Flags                , &
!                    f0                    = f0                   , &
!                    Planck_Coeffs         = Planck_Coeffs        , &
!                    Polychromatic_Coeffs  = Polychromatic_Coeffs, &
!                    Frequency             = Frequency            , &
!                    Response              = Response             , &
!                    Temperature           = Temperature          , &
!                    Effective_Temperature = Effective_Temperature, &
!                    Fit_Temperature       = Fit_Temperature        )
!
! OBJECT:
!   oSRF:                  oSRF object that is to have its properties
!                          modified.
!                          UNITS:      N/A
!                          TYPE:       TYPE(oSRF_type)
!                          DIMENSION:  Scalar
!                          ATTRIBUTES: INTENT(IN OUT)
!
!
! OPTIONAL INPUTS:
!   Band:                  The band number to which the frequency and
!                          response data refer.
!                          If not specified, default value is 1.
!                          UNITS:      N/A
!                          TYPE:       INTEGER
!                          DIMENSION:  Scalar
!                          ATTRIBUTES: INTENT(IN), OPTIONAL
!
!   Version:               The version number of the SRF data.
!                          UNITS:      N/A
!                          TYPE:       INTEGER
!                          DIMENSION:  Scalar
!                          ATTRIBUTES: INTENT(IN), OPTIONAL
!
!   Sensor_ID:             A character string identifying the sensor and
!                          satellite platform used to contruct filenames.
!                          UNITS:      N/A
!                          TYPE:       CHARACTER
!                          DIMENSION:  Scalar
!                          ATTRIBUTES: INTENT(IN), OPTIONAL
!
!   WMO_Satellite_ID:      The WMO code used to identify satellite platforms.
!                          UNITS:      N/A
!                          TYPE:       INTEGER
!                          DIMENSION:  Scalar
!                          ATTRIBUTES: INTENT(IN), OPTIONAL
!
!   WMO_Sensor_ID:         The WMO code used to identify sensors.
!                          UNITS:      N/A
!                          TYPE:       INTEGER
!                          DIMENSION:  Scalar
!                          ATTRIBUTES: INTENT(IN), OPTIONAL
!
!   Sensor_Type:           The flag indicating the type of sensor (IR, MW, etc)
!                          UNITS:      N/A
!                          TYPE:       INTEGER
!                          DIMENSION:  Scalar
!                          ATTRIBUTES: INTENT(IN), OPTIONAL
!
!   Channel:               The sensor channel number.
!                          UNITS:      N/A
!                          TYPE:       INTEGER
!                          DIMENSION:  Scalar
!                          ATTRIBUTES: INTENT(IN), OPTIONAL
!
!   Integral:              The integrated SRF value.
!                          UNITS:      N/A
!                          TYPE:       REAL(fp)
!                          DIMENSION:  Scalar
!                          ATTRIBUTES: INTENT(IN), OPTIONAL
!
!   Flags:                 Bit flags set/cleared during SRF processing.
!                          UNITS:      N/A
!                          TYPE:       INTEGER
!                          DIMENSION:  Scalar
!                          ATTRIBUTES: INTENT(IN), OPTIONAL
!
!   f0:                    The central frequency of the SRF.
!                          UNITS:      Inverse centimetres (cm^-1)
!                          TYPE:       REAL(fp)
!                          DIMENSION:  Scalar
!                          ATTRIBUTES: INTENT(IN), OPTIONAL
!
!   Planck_Coeffs:         Vector of Planck function coefficients for the SRF.
!                          UNITS:      Variable
!                          TYPE:       REAL(fp)
!                          DIMENSION:  Rank-1
!                          ATTRIBUTES: INTENT(IN), OPTIONAL
!
!   Polychromatic_Coeffs:  Vector of polychromatic correction coefficients for the SRF.
!                          UNITS:      Variable
!                          TYPE:       REAL(fp)
!                          DIMENSION:  Rank-1
!                          ATTRIBUTES: INTENT(IN), OPTIONAL
!
!   Frequency:             The frequency grid for an SRF band.
!                          Used in conjunction with the Band keyword argument.
!                          NOTE: If this argument is supplied, the Response argument
!                                must also be supplied.
!                          UNITS:      Inverse centimetres (cm^-1)
!                          TYPE:       REAL(fp)
!                          DIMENSION:  Rank-1
!                          ATTRIBUTES: INTENT(IN), OPTIONAL
!
!   Response:              The response data for an SRF band.
!                          Used in conjunction with the Band keyword argument.
!                          NOTE: If this argument is supplied, the Frequency argument
!                                must also be supplied.
!                          UNITS:      N/A
!                          TYPE:       REAL(fp)
!                          DIMENSION:  Rank-1
!                          ATTRIBUTES: INTENT(IN), OPTIONAL
!
!   Temperature:           The array of temperatures used in determining the
!                          polychromatic correction coefficients.
!                          UNITS:      N/A
!                          TYPE:       REAL(fp)
!                          DIMENSION:  Rank-1
!                          ATTRIBUTES: INTENT(IN), OPTIONAL
!
!   Effective_Temperature: The array of effective temperatures used in
!                          determining the polychromatic correction
!                          coefficients.
!                          UNITS:      N/A
!                          TYPE:       REAL(fp)
!                          DIMENSION:  Rank-1
!                          ATTRIBUTES: INTENT(IN), OPTIONAL
!
!   Fit_Temperature:       The array of temperatures derived from using
!                          the polychromatic correction coefficients.
!                          UNITS:      N/A
!                          TYPE:       REAL(fp)
!                          DIMENSION:  Rank-1
!                          ATTRIBUTES: INTENT(IN), OPTIONAL
!
! FUNCTION RESULT:
!   Error_Status:          The return value is an integer defining the error
!                          status. The error codes are defined in the
!                          Message_Handler module.
!                          If == SUCCESS the property set succeeded
!                             == FAILURE an error occurred
!                          UNITS:      N/A
!                          TYPE:       INTEGER
!                          DIMENSION:  Scalar
!
!:sdoc-:
!--------------------------------------------------------------------------------

  FUNCTION oSRF_SetValue( &
    self                 , &  ! In/output
    Band                 , &  ! Optional input
    Version              , &  ! Optional input
    Sensor_Id            , &  ! Optional input
    WMO_Satellite_Id     , &  ! Optional input
    WMO_Sensor_Id        , &  ! Optional input
    Sensor_Type          , &  ! Optional input
    Channel              , &  ! Optional input
    Integral             , &  ! Optional input
    Flags                , &  ! Optional input
    f0                   , &  ! Optional input
    Planck_Coeffs        , &  ! Optional input
    Polychromatic_Coeffs, &  ! Optional input
    Frequency            , &  ! Optional input
    Response             , &  ! Optional input
    Temperature          , &  ! Optional input
    Effective_Temperature, &  ! Optional input
    Fit_Temperature      ) &  ! Optional input
  RESULT( err_stat )
    ! Arguments
    TYPE(oSRF_type),        INTENT(IN OUT):: self
    INTEGER,      OPTIONAL, INTENT(IN)     :: Band
    INTEGER,      OPTIONAL, INTENT(IN)     :: Version
    CHARACTER(*), OPTIONAL, INTENT(IN)     :: Sensor_Id
    INTEGER,      OPTIONAL, INTENT(IN)     :: WMO_Satellite_Id
    INTEGER,      OPTIONAL, INTENT(IN)     :: WMO_Sensor_Id
    INTEGER,      OPTIONAL, INTENT(IN)     :: Sensor_Type
    INTEGER,      OPTIONAL, INTENT(IN)     :: Channel
    REAL(fp),     OPTIONAL, INTENT(IN)     :: Integral
    INTEGER,      OPTIONAL, INTENT(IN)     :: Flags
    REAL(fp),     OPTIONAL, INTENT(IN)     :: f0
    REAL(fp),     OPTIONAL, INTENT(IN)     :: Planck_Coeffs(:)
    REAL(fp),     OPTIONAL, INTENT(IN)     :: Polychromatic_Coeffs(:)
    REAL(fp),     OPTIONAL, INTENT(IN)     :: Frequency(:)
    REAL(fp),     OPTIONAL, INTENT(IN)     :: Response(:)
    REAL(fp),     OPTIONAL, INTENT(IN)     :: Temperature(:)
    REAL(fp),     OPTIONAL, INTENT(IN)     :: Effective_Temperature(:)
    REAL(fp),     OPTIONAL, INTENT(IN)     :: Fit_Temperature(:)
    ! Function result
    INTEGER:: err_stat
    ! Local parameters
    CHARACTER(*), PARAMETER:: ROUTINE_NAME = 'oSRF:: SetValue'
    ! Local variables
    CHARACTER(ML):: msg
    CHARACTER(ML):: name
    INTEGER:: l_band
    INTEGER:: n_pc, n_t
    INTEGER:: n_points

    ! Set up
    err_stat = SUCCESS


    ! Check if object has been allocated
    IF ( .NOT. oSRF_Associated(self) ) THEN
      msg = 'Input oSRF object is not allocated'
      CALL CleanUp(); RETURN
    END IF
 
  
    ! Check band argument
    l_band = 1
    IF ( PRESENT(Band) ) THEN
      l_band = Band
      IF ( l_band < 1 .OR. l_band > self%n_Bands ) THEN
        WRITE( msg, '("Invalid band, ",i0, ", specified for oSRF")' ) l_band
        CALL CleanUp(); RETURN
      END IF
    END IF


    ! Set scalars
    IF ( PRESENT(Version         ) ) self%Version          = Version
    IF ( PRESENT(Sensor_Id       ) ) self%Sensor_Id        = Sensor_Id
    IF ( PRESENT(WMO_Satellite_Id) ) self%WMO_Satellite_Id = WMO_Satellite_Id
    IF ( PRESENT(WMO_Sensor_Id   ) ) self%WMO_Sensor_Id    = WMO_Sensor_Id
    IF ( PRESENT(Sensor_Type     ) ) self%Sensor_Type      = Sensor_Type
    IF ( PRESENT(Channel         ) ) self%Channel          = Channel
    IF ( PRESENT(Integral        ) ) self%Integral         = Integral
    IF ( PRESENT(Flags           ) ) self%Flags            = Flags
    IF ( PRESENT(f0              ) ) self%f0               = f0


    ! Planck coeffs have a defined size, but input may be wrong.
    IF ( PRESENT(Planck_Coeffs) ) THEN
      n_pc = SIZE(Planck_Coeffs)
      IF ( n_pc /= N_PLANCK_COEFFS ) THEN
        err_stat = FAILURE
        WRITE(msg, '("Size of Planck coefficient array (",i0, &
                   &") is different from oSRF object (",i0, ")")') &
                   n_pc, N_PLANCK_COEFFS
        CALL CleanUp(); RETURN
      END IF
      self%Planck_Coeffs = Planck_Coeffs
    END IF
    

    ! Number of polychromatic coeffs could be different
    IF ( PRESENT(Polychromatic_Coeffs) ) THEN
      n_pc = SIZE(Polychromatic_Coeffs)
      IF ( n_pc /= self%n_Polychromatic_Coeffs ) THEN
        err_stat = FAILURE
        WRITE(msg, '("Size of polychromatic coefficient array (",i0, &
                   &") is different from oSRF object (",i0, ")")') &
                   n_pc, self%n_Polychromatic_Coeffs
        CALL CleanUp(); RETURN
      END IF
      self%Polychromatic_Coeffs = Polychromatic_Coeffs
    END IF


    ! Set frequency and response data
    IF ( PRESENT(Frequency) .NEQV. PRESENT(Response) ) THEN
      err_stat = FAILURE
      msg = 'Frequency and Response inputs MUST be supplied together'
      CALL CleanUp(); RETURN
    END IF
    ! ...If BOTH items have been set...
    IF ( PRESENT(Frequency) ) THEN
      n_points = SIZE(Frequency)
      ! ...Check data congruency
      IF ( SIZE(Response) /= n_points ) THEN
        err_stat = FAILURE
        msg = 'Frequency and Response inputs have different sizes'
        CALL CleanUp(); RETURN
      END IF
      ! ...Assign the data for the band
      WRITE(name, '("Band ",i0, " frequency")') l_band
      err_stat = PtrArr_SetValue( self%Frequency(l_band), Name = name, Arr = Frequency )
      IF ( err_stat /= SUCCESS ) THEN
        WRITE( msg, '("Error setting frequency array for band ",i0)' ) l_band
        CALL CleanUp(); RETURN
      END IF
      WRITE(name, '("Band ",i0, " response")') l_band
      err_stat = PtrArr_SetValue( self%Response(l_band), Name = name, Arr = Response )
      IF ( err_stat /= SUCCESS ) THEN
        WRITE( msg, '("Error setting response array for band ",i0)' ) l_band
        CALL CleanUp(); RETURN
      END IF
      ! ...Set the frequency limits
      self%f1(l_band) = Frequency(1)
      self%f2(l_band) = Frequency(n_points)
      ! ...Set the point numbering
      self%n_Points(l_band) = n_points
    END IF


    ! Set the temperature data
    IF ( PRESENT(Temperature) ) THEN
      n_t = SIZE(Temperature)
      IF ( n_t /= self%n_Temperatures ) THEN
        err_stat = FAILURE
        WRITE(msg, '("Size of temperature array (",i0, &
                   &") is different from oSRF object (",i0, ")")') &
                   n_t, self%n_Temperatures
        CALL CleanUp(); RETURN
      END IF
      self%Temperature = Temperature
    END IF
    IF ( PRESENT(Effective_Temperature) ) THEN
      n_t = SIZE(Effective_Temperature)
      IF ( n_t /= self%n_Temperatures ) THEN
        err_stat = FAILURE
        WRITE(msg, '("Size of effective temperature array (",i0, &
                   &") is different from oSRF object (",i0, ")")') &
                   n_t, self%n_Temperatures
        msg = 'Effective_Temperature input has different size from allocated oSRF object'
        CALL CleanUp(); RETURN
      END IF
      self%Effective_Temperature = Effective_Temperature
    END IF
    IF ( PRESENT(Fit_Temperature) ) THEN
      n_t = SIZE(Fit_Temperature)
      IF ( n_t /= self%n_Temperatures ) THEN
        err_stat = FAILURE
        WRITE(msg, '("Size of fit temperature array (",i0, &
                   &") is different from oSRF object (",i0, ")")') &
                   n_t, self%n_Temperatures
        msg = 'Fit_Temperature input has different size from allocated oSRF object'
        CALL CleanUp(); RETURN
      END IF
      self%Fit_Temperature = Fit_Temperature
    END IF
      
  CONTAINS

    SUBROUTINE CleanUp()
      err_stat = FAILURE
      CALL Display_Message( ROUTINE_NAME, msg, err_stat )
    END SUBROUTINE CleanUp

  END FUNCTION oSRF_SetValue




!--------------------------------------------------------------------------------
!:sdoc+:
!
! NAME:
!   oSRF_GetValue
!
! PURPOSE:
!   Function to get the value of an oSRF object component.
!
! CALLING SEQUENCE:
!   Error_Status = oSRF_GetValue( &
!                    oSRF                                           , &
!                    Band                   = Band                  , &
!                    n_Bands                = n_Bands               , &
!                    n_Temperatures         = n_Temperatures        , &
!                    n_Polychromatic_Coeffs = n_Polychromatic_Coeffs, &
!                    Version                = Version               , &
!                    Sensor_Id              = Sensor_Id             , &
!                    WMO_Satellite_Id       = WMO_Satellite_Id      , &
!                    WMO_Sensor_Id          = WMO_Sensor_Id         , &
!                    Sensor_Type            = Sensor_Type           , &
!                    Channel                = Channel               , &
!                    Integral               = Integral              , &
!                    Flags                  = Flags                 , &
!                    f0                     = f0                    , &
!                    Planck_Coeffs          = Planck_Coeffs         , &
!                    Polychromatic_Coeffs   = Polychromatic_Coeffs  , &
!                    n_Points               = n_Points              , &
!                    n_Band_Points          = n_Band_Points         , &
!                    f1                     = f1                    , &
!                    f2                     = f2                    , &
!                    Frequency              = Frequency             , &
!                    Response               = Response              , &
!                    Passband_Frequency     = Passband_Frequency    , &
!                    Passband_Response      = Passband_Response     , &
!                    Temperature            = Temperature           , &
!                    Effective_Temperature  = Effective_Temperature, &
!                    Fit_Temperature        = Fit_Temperature         )
!
! OBJECT:
!   oSRF:                   oSRF object that is to have its properties
!                           retrieved.
!                           UNITS:      N/A
!                           TYPE:       TYPE(oSRF_type)
!                           DIMENSION:  Scalar
!                           ATTRIBUTES: INTENT(IN)
!
! OPTIONAL INPUTS:
!   Band:                   The band number to which the frequency and
!                           response data refer.
!                           If not specified, default value is 1.
!                           UNITS:      N/A
!                           TYPE:       INTEGER
!                           DIMENSION:  Scalar
!                           ATTRIBUTES: INTENT(IN), OPTIONAL
!
! OPTIONAL OUTPUTS:
!   n_Bands:                The number of bands dimension of the SRF.
!                           UNITS:      N/A
!                           TYPE:       INTEGER
!                           DIMENSION:  Scalar
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL
!
!   n_Temperatures:         The number of temperatures used to compute the
!                           polychromatic correction coefficients.
!                           UNITS:      N/A
!                           TYPE:       INTEGER
!                           DIMENSION:  Scalar
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL
!
!   n_Polychromatic_Coeffs: The number of polychromatic correction coefficients.
!                           UNITS:      N/A
!                           TYPE:       INTEGER
!                           DIMENSION:  Scalar
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL
!
!   Version:                The version number of the SRF data.
!                           UNITS:      N/A
!                           TYPE:       INTEGER
!                           DIMENSION:  Scalar
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL
!
!   Sensor_ID:              A character string identifying the sensor and
!                           satellite platform used to contruct filenames.
!                           UNITS:      N/A
!                           TYPE:       CHARACTER
!                           DIMENSION:  Scalar
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL
!
!   WMO_Satellite_ID:       The WMO code used to identify satellite platforms.
!                           UNITS:      N/A
!                           TYPE:       INTEGER
!                           DIMENSION:  Scalar
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL
!
!   WMO_Sensor_ID:          The WMO code used to identify sensors.
!                           UNITS:      N/A
!                           TYPE:       INTEGER
!                           DIMENSION:  Scalar
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL
!
!   Sensor_Type:            The flag indicating the type of sensor (IR, MW, etc)
!                           UNITS:      N/A
!                           TYPE:       INTEGER
!                           DIMENSION:  Scalar
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL
!
!   Channel:                The sensor channel number.
!                           UNITS:      N/A
!                           TYPE:       INTEGER
!                           DIMENSION:  Scalar
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL
!
!   Integral:               The integrated SRF value.
!                           UNITS:      N/A
!                           TYPE:       REAL(fp)
!                           DIMENSION:  Scalar
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL
!
!   Flags:                  Bit flags set/cleared during SRF processing.
!                           UNITS:      N/A
!                           TYPE:       INTEGER
!                           DIMENSION:  Scalar
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL
!
!   f0:                     The central frequency of the SRF.
!                           UNITS:      Inverse centimetres (cm^-1)
!                           TYPE:       REAL(fp)
!                           DIMENSION:  Scalar
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL
!
!   Planck_Coeffs:          Vector of Planck function coefficients for the SRF.
!                           UNITS:      Variable
!                           TYPE:       REAL(fp)
!                           DIMENSION:  Rank-1
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL, ALLOCATABLE
!
!   Polychromatic_Coeffs:   Vector of polychromatic correction coefficient for the SRF.
!                           UNITS:      Variable
!                           TYPE:       REAL(fp)
!                           DIMENSION:  Rank-1
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL, ALLOCATABLE
!
!   n_Points:               Array of the number of points for each passband of the SRF.
!                           UNITS:      N/A
!                           TYPE:       INTEGER
!                           DIMENSION:  Rank-1
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL, ALLOCATABLE
!
!   n_Band_Points:          The number of points that specify the passband frequency
!                           and response data.
!                           - Used in conjunction with the Band keyword argument.
!                           UNITS:      N/A
!                           TYPE:       INTEGER
!                           DIMENSION:  Scalar
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL
!
!   f1:                     The begin frequency of the SRF passband.
!                           - Used in conjunction with the Band keyword argument.
!                           UNITS:      Inverse centimetres (cm^-1)
!                           TYPE:       REAL(fp)
!                           DIMENSION:  Scalar
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL
!
!   f2:                     The end frequency of the SRF passband.
!                           - Used in conjunction with the Band keyword argument.
!                           UNITS:      Inverse centimetres (cm^-1)
!                           TYPE:       REAL(fp)
!                           DIMENSION:  Scalar
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL
!
!   Frequency:              The frequency grid for an SRF band.
!                           - Used in conjunction with the Band keyword argument.
!                           UNITS:      Inverse centimetres (cm^-1)
!                           TYPE:       REAL(fp)
!                           DIMENSION:  Rank-1
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL, ALLOCATABLE
!
!   Response:               The response data for an SRF band.
!                           - Used in conjunction with the Band keyword argument.
!                           UNITS:      N/A
!                           TYPE:       REAL(fp)
!                           DIMENSION:  Rank-1
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL, ALLOCATABLE
!
!   Passband_Frequency:     The frequency arrays for all the SRF bands.
!                           UNITS:      Inverse centimetres (cm^-1)
!                           TYPE:       TYPE(PtrArr_type)
!                           DIMENSION:  Rank-1
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL, ALLOCATABLE
!
!   Passband_Response:      The response data for ALL the SRF bands.
!                           UNITS:      N/A
!                           TYPE:       TYPE(PtrArr_type)
!                           DIMENSION:  Rank-1
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL, ALLOCATABLE
!
!   Temperature:            The array of temperatures used in determining the
!                           polychromatic correction coefficients.
!                           UNITS:      N/A
!                           TYPE:       REAL(fp)
!                           DIMENSION:  Rank-1
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL, ALLOCATABLE
!
!   Effective_Temperature:  The array of effective temperatures used in
!                           determining the polychromatic correction
!                           coefficients.
!                           UNITS:      N/A
!                           TYPE:       REAL(fp)
!                           DIMENSION:  Rank-1
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL, ALLOCATABLE
!
!   Fit_Temperature:        The array of temperatures derived from using
!                           the polychromatic correction coefficients.
!                           UNITS:      N/A
!                           TYPE:       REAL(fp)
!                           DIMENSION:  Rank-1
!                           ATTRIBUTES: INTENT(OUT), OPTIONAL, ALLOCATABLE
!
! FUNCTION RESULT:
!   Error_Status:           The return value is an integer defining the error
!                           status. The error codes are defined in the
!                           Message_Handler module.
!                           If == SUCCESS the property get succeeded
!                              == FAILURE an error occurred
!                           UNITS:      N/A
!                           TYPE:       INTEGER
!                           DIMENSION:  Scalar
!
!:sdoc-:
!--------------------------------------------------------------------------------

  FUNCTION oSRF_GetValue( &
    self                  , &  ! Input
    Band                  , &  ! Optional input
    n_Bands               , &  ! Optional output
    n_Temperatures        , &  ! Optional output
    n_Polychromatic_Coeffs, &  ! Optional output
    Version               , &  ! Optional output
    Sensor_Id             , &  ! Optional output
    WMO_Satellite_Id      , &  ! Optional output
    WMO_Sensor_Id         , &  ! Optional output
    Sensor_Type           , &  ! Optional output
    Channel               , &  ! Optional output
    Integral              , &  ! Optional output
    Flags                 , &  ! Optional output
    f0                    , &  ! Optional output
    Planck_Coeffs         , &  ! Optional output
    Polychromatic_Coeffs  , &  ! Optional output
    n_Points              , &  ! Optional output
    n_Band_Points         , &  ! Optional output
    f1                    , &  ! Optional output
    f2                    , &  ! Optional output
    Frequency             , &  ! Optional output
    Response              , &  ! Optional output
    Passband_Frequency    , &  ! Optional output
    Passband_Response     , &  ! Optional output
    Temperature           , &  ! Optional output
    Effective_Temperature, &  ! Optional output
    Fit_Temperature       ) &  ! Optional output
  RESULT( err_stat )
    ! Arguments
    TYPE(oSRF_type),                          INTENT(IN)  :: self
    INTEGER,           OPTIONAL,              INTENT(IN)  :: Band
    INTEGER,           OPTIONAL,              INTENT(OUT):: n_Bands
    INTEGER,           OPTIONAL,              INTENT(OUT):: n_Temperatures        
    INTEGER,           OPTIONAL,              INTENT(OUT):: n_Polychromatic_Coeffs
    INTEGER,           OPTIONAL,              INTENT(OUT):: Version
    CHARACTER(*),      OPTIONAL,              INTENT(OUT):: Sensor_Id
    INTEGER,           OPTIONAL,              INTENT(OUT):: WMO_Satellite_Id
    INTEGER,           OPTIONAL,              INTENT(OUT):: WMO_Sensor_Id
    INTEGER,           OPTIONAL,              INTENT(OUT):: Sensor_Type
    INTEGER,           OPTIONAL,              INTENT(OUT):: Channel
    REAL(fp),          OPTIONAL,              INTENT(OUT):: Integral
    INTEGER,           OPTIONAL,              INTENT(OUT):: Flags
    REAL(fp),          OPTIONAL,              INTENT(OUT):: f0
    REAL(fp),          OPTIONAL, ALLOCATABLE, INTENT(OUT):: Planck_Coeffs(:)
    REAL(fp),          OPTIONAL, ALLOCATABLE, INTENT(OUT):: Polychromatic_Coeffs(:)
    INTEGER,           OPTIONAL, ALLOCATABLE, INTENT(OUT):: n_Points(:)
    INTEGER,           OPTIONAL,              INTENT(OUT):: n_Band_Points
    REAL(fp),          OPTIONAL,              INTENT(OUT):: f1
    REAL(fp),          OPTIONAL,              INTENT(OUT):: f2
    REAL(fp),          OPTIONAL, ALLOCATABLE, INTENT(OUT):: Frequency(:)
    REAL(fp),          OPTIONAL, ALLOCATABLE, INTENT(OUT):: Response(:)
    TYPE(PtrArr_type), OPTIONAL, ALLOCATABLE, INTENT(OUT):: Passband_Frequency(:)
    TYPE(PtrArr_type), OPTIONAL, ALLOCATABLE, INTENT(OUT):: Passband_Response(:)
    REAL(fp),          OPTIONAL, ALLOCATABLE, INTENT(OUT):: Temperature(:)          
    REAL(fp),          OPTIONAL, ALLOCATABLE, INTENT(OUT):: Effective_Temperature(:)
    REAL(fp),          OPTIONAL, ALLOCATABLE, INTENT(OUT):: Fit_Temperature(:)      
    ! Function result
    INTEGER:: err_stat
    ! Local parameters
    CHARACTER(*), PARAMETER:: ROUTINE_NAME = 'oSRF:: GetValue'
    ! Local variables
    CHARACTER(ML):: msg
    CHARACTER(ML):: alloc_msg
    CHARACTER(ML):: name
    INTEGER:: alloc_stat
    INTEGER:: l_band

    ! Set up
    err_stat = SUCCESS


    ! Check if object has been allocated
    IF ( .NOT. oSRF_Associated(self) ) THEN
      msg = 'Input oSRF object is not allocated'
      CALL CleanUp(); RETURN
    END IF
 
  
    ! Check band argument
    l_band = 1
    IF ( PRESENT(Band) ) THEN
      l_band = Band
      IF ( l_band < 1 .OR. l_band > self%n_Bands ) THEN
        WRITE( msg, '("Invalid band, ",i0, ", specified for input oSRF")' ) l_band
        CALL CleanUp(); RETURN
      END IF
    END IF


    ! Get scalar data
    IF ( PRESENT(n_Bands               ) ) n_Bands                = self%n_Bands
    IF ( PRESENT(n_Temperatures        ) ) n_Temperatures         = self%n_Temperatures        
    IF ( PRESENT(n_Polychromatic_Coeffs) ) n_Polychromatic_Coeffs = self%n_Polychromatic_Coeffs
    IF ( PRESENT(Version               ) ) Version                = self%Version
    IF ( PRESENT(Sensor_Id             ) ) Sensor_Id              = self%Sensor_Id
    IF ( PRESENT(WMO_Satellite_Id      ) ) WMO_Satellite_Id       = self%WMO_Satellite_Id
    IF ( PRESENT(WMO_Sensor_Id         ) ) WMO_Sensor_Id          = self%WMO_Sensor_Id
    IF ( PRESENT(Sensor_Type           ) ) Sensor_Type            = self%Sensor_Type
    IF ( PRESENT(Channel               ) ) Channel                = self%Channel
    IF ( PRESENT(Integral              ) ) Integral               = self%Integral
    IF ( PRESENT(Flags                 ) ) Flags                  = self%Flags
    IF ( PRESENT(f0                    ) ) f0                     = self%f0
    IF ( PRESENT(n_Band_Points         ) ) n_Band_Points          = self%n_Points(l_band)
    IF ( PRESENT(f1                    ) ) f1                     = self%f1(l_band)
    IF ( PRESENT(f2                    ) ) f2                     = self%f2(l_band)


    ! Get Planck coefficient data
    IF ( PRESENT(Planck_Coeffs) ) THEN
      ALLOCATE(Planck_Coeffs(N_PLANCK_COEFFS), STAT = alloc_stat, ERRMSG = alloc_msg)
      IF ( alloc_stat /= 0 ) THEN
        err_stat = FAILURE
        msg = 'Error allocating output Planck_Coeffs array - '//TRIM(alloc_msg)
        CALL Cleanup(); RETURN
      END IF
      Planck_Coeffs = self%Planck_Coeffs
    END IF
    

    ! Get polychromatic coefficient data
    IF ( PRESENT(Polychromatic_Coeffs) ) THEN
      ALLOCATE(Polychromatic_Coeffs(self%n_Polychromatic_Coeffs), STAT = alloc_stat, ERRMSG = alloc_msg)
      IF ( alloc_stat /= 0 ) THEN
        err_stat = FAILURE
        msg = 'Error allocating output polychromatic_Coeffs array - '//TRIM(alloc_msg)
        CALL Cleanup(); RETURN
      END IF
      Polychromatic_Coeffs = self%Polychromatic_Coeffs
    END IF
    

    ! Get n_Points data
    IF ( PRESENT(n_Points) ) THEN
      ALLOCATE(n_Points(self%n_Bands), STAT = alloc_stat, ERRMSG = alloc_msg)
      IF ( alloc_stat /= 0 ) THEN
        err_stat = FAILURE
        msg = 'Error allocating output n_Points array - '//TRIM(alloc_msg)
        CALL Cleanup(); RETURN
      END IF
      n_Points = self%n_Points
    END IF


    ! Get frequency data
    IF ( PRESENT(Frequency) ) THEN
      err_stat = PtrArr_GetValue( self%Frequency(l_band), Name = name, Arr = Frequency )
      IF ( err_stat /= SUCCESS ) THEN
        msg = 'Error retrieving '//TRIM(name)
        CALL CleanUp(); RETURN
      END IF
    END IF
    IF ( PRESENT(Passband_Frequency) ) THEN
      Passband_Frequency = self%Frequency
      IF ( .NOT. ALL(PtrArr_Associated(Passband_Frequency)) ) THEN
        msg = 'Error retrieving passband frequency array'
        CALL CleanUp(); RETURN
      END IF
    END IF


    ! Get Response data
    IF ( PRESENT(Response) ) THEN
      err_stat = PtrArr_GetValue( self%Response(l_band), Name = name, Arr = Response )
      IF ( err_stat /= SUCCESS ) THEN
        msg = 'Error retrieving '//TRIM(name)
        CALL CleanUp(); RETURN
      END IF
    END IF
    IF ( PRESENT(Passband_Response) ) THEN
      Passband_Response = self%Response
      IF ( .NOT. ALL(PtrArr_Associated(Passband_Response)) ) THEN
        msg = 'Error retrieving passband response array'
        CALL CleanUp(); RETURN
      END IF
    END IF


    ! Get temperature data
    IF ( PRESENT(Temperature) ) THEN
      ALLOCATE(Temperature(self%n_Temperatures), STAT = alloc_stat, ERRMSG = alloc_msg)
      IF ( alloc_stat /= 0 ) THEN
        err_stat = FAILURE
        msg = 'Error allocating output Temperature array - '//TRIM(alloc_msg)
        CALL Cleanup(); RETURN
      END IF
      Temperature = self%Temperature
    END IF
    IF ( PRESENT(Effective_Temperature) ) THEN
      ALLOCATE(Effective_Temperature(self%n_Temperatures), STAT = alloc_stat, ERRMSG = alloc_msg)
      IF ( alloc_stat /= 0 ) THEN
        err_stat = FAILURE
        msg = 'Error allocating output Effective_Temperature array - '//TRIM(alloc_msg)
        CALL Cleanup(); RETURN
      END IF
      Effective_Temperature = self%Effective_Temperature
    END IF
    IF ( PRESENT(Fit_Temperature) ) THEN
      ALLOCATE(Fit_Temperature(self%n_Temperatures), STAT = alloc_stat, ERRMSG = alloc_msg)
      IF ( alloc_stat /= 0 ) THEN
        err_stat = FAILURE
        msg = 'Error allocating output Fit_Temperature array - '//TRIM(alloc_msg)
        CALL Cleanup(); RETURN
      END IF
      Fit_Temperature = self%Fit_Temperature
    END IF

  CONTAINS

    SUBROUTINE CleanUp()
      err_stat = FAILURE
      CALL Display_Message( ROUTINE_NAME, msg, err_stat )
    END SUBROUTINE CleanUp

  END FUNCTION oSRF_GetValue


!--------------------------------------------------------------------------------
!:sdoc+:
!
! NAME:
!   oSRF_Inspect
!
! PURPOSE:
!   Subroutine to view the contents of an oSRF structure.
!
! CALLING SEQUENCE:
!   CALL oSRF_Inspect( oSRF )
!
! OBJECT:
!   oSRF:          oSRF structure to inspect.
!                  UNITS:      N/A
!                  TYPE:       TYPE(oSRF_type)
!                  DIMENSION:  Scalar
!                  ATTRIBUTES: INTENT(IN)
!
!:sdoc-:
!--------------------------------------------------------------------------------

  SUBROUTINE oSRF_Inspect( self )
    ! Arguments
    TYPE(oSRF_type), INTENT(IN):: self
    ! Local arguments
    INTEGER:: i, n
    ! Output the oSRF components
    WRITE(*,'(1x, "oSRF OBJECT")')
    ! Dimensions
    WRITE(*,'(3x, "n_Bands              :",1x, i0)') self%n_Bands
    ! Scalar data
    WRITE(*,'(3x, "Release              : ",i0)'             ) self%Release
    WRITE(*,'(3x, "Version              : ",i0)'             ) self%Version
    WRITE(*,'(3x, "Sensor_Id            : ", a)'             ) self%Sensor_Id
    WRITE(*,'(3x, "WMO_Satellite_Id     : ",i0)'             ) self%WMO_Satellite_Id
    WRITE(*,'(3x, "WMO_Sensor_Id        : ",i0)'             ) self%WMO_Sensor_Id
    WRITE(*,'(3x, "Sensor_Type          : ", a)'             ) SENSOR_TYPE_NAME(self%Sensor_Type)
    WRITE(*,'(3x, "Channel              : ",i0)'             ) self%Channel
    WRITE(*,'(3x, "Integral             : ",es13.6)'         ) self%Integral
    WRITE(*,'(3x, "Flags                : ",i0)'             ) self%Flags
    WRITE(*,'(3x, "f0                   : ",es13.6)'         ) self%f0
    IF ( oSRF_Associated(self) ) THEN
      ! Coefficient arrays
      WRITE(*,'(3x, "Planck_Coeffs        : ",99(es13.6, :,1x))') self%Planck_Coeffs
      WRITE(*,'(3x, "Polychromatic_Coeffs : ",99(es13.6, :,1x))') self%Polychromatic_Coeffs
      ! Band data
      DO n = 1, self%n_Bands
        WRITE(*,'(/3x, "BAND NUMBER ",i0)') n
        WRITE(*,'(5x, "n_Points  : ",i0)'    ) self%n_Points(n)
        WRITE(*,'(5x, "f1        : ",es13.6)') self%f1(n)
        WRITE(*,'(5x, "f2        : ",es13.6)') self%f2(n)
        WRITE(*,'(5x, "Frequency :")')
        CALL PtrArr_Inspect( self%Frequency(n) )
        WRITE(*,'(5x, "Response  :")')
        CALL PtrArr_Inspect( self%Response(n) )
      END DO
      ! Temperature data
      WRITE(*,'(/3x, "TEMPERATURE DATA")')
      WRITE(*,'(13x, "T           Teff         Tfit        Teff-Tfit ")')
      DO i = 1, self%n_Temperatures
        WRITE(*,'(5x, i2, 3(2x, f11.6), 2x, es13.6)') &
          i, &
          self%Temperature(i), &
          self%Effective_Temperature(i), &
          self%Fit_Temperature(i), &
          self%Effective_Temperature(i) - self%Fit_Temperature(i)
      END DO
    END IF

  END SUBROUTINE oSRF_Inspect


!--------------------------------------------------------------------------------
!:sdoc+:
!
! NAME:
!   oSRF_Info
!
! PURPOSE:
!   Subroutine to return a string containing version and dimension
!   information about the oSRF data structure.
!
! CALLING SEQUENCE:
!   CALL oSRF_Info( oSRF, Info )
!
! OBJECT:
!   oSRF:          oSRF structure.
!                  UNITS:      N/A
!                  TYPE:       TYPE(oSRF_type)
!                  DIMENSION:  Scalar
!                  ATTRIBUTES: INTENT(IN)
!
! OUTPUTS:
!   Info:          String containing version and dimension information
!                  about the passed oSRF data structure.
!                  UNITS:      N/A
!                  TYPE:       CHARACTER(*)
!                  DIMENSION:  Scalar
!                  ATTRIBUTES: INTENT(OUT)
!
!:sdoc-:
!--------------------------------------------------------------------------------

  SUBROUTINE oSRF_Info( self, Info )
    ! Arguments
    TYPE(oSRF_type), INTENT(IN)  :: self
    CHARACTER(*)   , INTENT(OUT):: Info
    ! Parameters
    INTEGER, PARAMETER:: CARRIAGE_RETURN = 13
    INTEGER, PARAMETER:: LINEFEED = 10
    ! Local variables
    CHARACTER(2000):: LongString

    ! Setup
    Info = ' '
    IF ( .NOT. oSRF_Associated(self) ) RETURN


    ! Write the required data to the local string
    WRITE( LongString, '(a, 1x, "oSRF RELEASE.VERSION: ",i0, ".",i2.2, 2x, a, 1x, &
                       &"CHANNEL:",i0, 2x, &
                       &"N_BANDS=",i0, 2x, &
                       &"N_TEMPERATURES=",i0, 2x, &
                       &"N_POLY_COEFFS=",i0, 2x, &
                       &"N_POINTS=",99(i0, :,","))' ) &
                       ACHAR(CARRIAGE_RETURN)//ACHAR(LINEFEED), &
                       self%Release, self%Version, &
                       TRIM(self%Sensor_ID), &
                       self%Channel, &
                       self%n_Bands, &
                       self%n_Temperatures, &
                       self%n_Polychromatic_Coeffs, &
                       self%n_Points


    ! Trim the output based on the
    ! dummy argument string length
    Info = LongString(1:MIN(LEN(Info), LEN_TRIM(LongString)))

  END SUBROUTINE oSRF_Info


!------------------------------------------------------------------------------
!:sdoc+:
!
! NAME:
!   oSRF_Integrate
!
! PURPOSE:
!   Function to integrate the response and set the integrated value
!   in an oSRF object.
!
! CALLING SEQUENCE:
!   Error_Status = oSRF_Integrate( oSRF )
!
! OBJECT:
!   oSRF:         oSRF structure.
!                 UNITS:      N/A
!                 TYPE:       TYPE(oSRF_type)
!                 DIMENSION:  Scalar
!                 ATTRIBUTES: INTENT(IN OUT)
!
! FUNCTION RESULT:
!   Error_Status: The return value is an integer defining the error status.
!                 The error codes are defined in the Message_Handler module.
!                 If == SUCCESS the integration was successful
!                    == FAILURE an error occurred processing the input
!                 UNITS:      N/A
!                 TYPE:       INTEGER
!                 DIMENSION:  Scalar
!
! SIDE EFFECTS:
!   The INTEGRAL component of the oSRF object is set in this function.
!
!:sdoc-:
!------------------------------------------------------------------------------

  FUNCTION oSRF_Integrate( self ) RESULT( err_stat )
    ! Arguments
    TYPE(oSRF_type), INTENT(IN OUT):: self
    ! Function result
    INTEGER:: err_stat
    ! Local parameters
    CHARACTER(*), PARAMETER:: ROUTINE_NAME = 'oSRF:: Integrate'
    ! Local variables
    CHARACTER(ML):: msg
    INTEGER:: n
    REAL(fp), ALLOCATABLE:: f(:), r(:)
    REAL(fp):: int_srf, int_band

    ! Setup
    err_stat = SUCCESS
    Int_SRF = ZERO
    ! ...Check object contains something
    IF ( .NOT. oSRF_Associated(self) ) THEN
      err_stat = FAILURE
      msg = 'Input oSRF object is empty'
      CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
    END IF


    ! Sum up band integrals
    Band_Loop: DO n = 1, self%n_Bands

      ! Get band response
      err_stat = oSRF_GetValue( self, Band = n, Frequency = f, Response = r )
      IF ( err_stat /= SUCCESS ) THEN
        WRITE( msg, '("Error occurred retrieving band#",i0, " data")' ) n
        CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
      END IF

      ! Integrate the band
      err_stat = Integral(f, r, int_band)
      IF ( err_stat /= SUCCESS ) THEN
        WRITE( msg, '("Error integrating band#",i0, " response")' ) n
        CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
      END IF

      ! Accumulate
      int_srf = int_srf+int_band

      ! Clean up
      DEALLOCATE( f, r )

    END DO Band_Loop


    ! Save the integrated value
    err_stat = oSRF_SetValue( self, Integral = int_srf )
    IF ( err_stat /= SUCCESS ) THEN
      msg = 'Error occurred saving the oSRF integral'
      CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
    END IF
    CALL oSRF_Set_Integrated( self )

  END FUNCTION oSRF_Integrate


!------------------------------------------------------------------------------
!:sdoc+:
!
! NAME:
!   oSRF_Planck_Coefficients
!
! PURPOSE:
!   Function to compute Planck coefficients for an oSRF_type.
!
! CALLING SEQUENCE:
!   Error_Status = oSRF_Planck_Coefficients( oSRF )
!
! OBJECT:
!   oSRF:         oSRF structure.
!                 UNITS:      N/A
!                 TYPE:       TYPE(oSRF_type)
!                 DIMENSION:  Scalar
!                 ATTRIBUTES: INTENT(IN OUT)
!
! FUNCTION RESULT:
!   Error_Status: The return value is an integer defining the error status.
!                 The error codes are defined in the Message_Handler module.
!                 If == SUCCESS the integration was successful
!                    == FAILURE an error occurred processing the input
!                 UNITS:      N/A
!                 TYPE:       INTEGER
!                 DIMENSION:  Scalar
!
! SIDE EFFECTS:
!   The Planck Coefficient components are set in oSRF.
!
!:sdoc-:
!------------------------------------------------------------------------------

  FUNCTION oSRF_Planck_Coefficients( self ) RESULT( err_stat )
    ! Arguments
    TYPE(oSRF_type), INTENT(IN OUT):: self
    ! Function result
    INTEGER:: err_stat
    ! Local parameters
    CHARACTER(*), PARAMETER:: ROUTINE_NAME = 'oSRF:: Planck_Coefficients'
    ! Local variables
    CHARACTER(ML):: msg
    REAL(fp):: Planck_Coeffs(N_PLANCK_COEFFS)
    REAL(fp):: f0

    ! Set up
    err_stat = SUCCESS
    ! ...Check object contains something
    IF ( .NOT. oSRF_Associated(self) ) THEN
      err_stat = FAILURE
      msg = 'Input oSRF object is empty'
      CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
    END IF


    ! Compute the central frequency if necessary
    IF ( .NOT. oSRF_Is_F0_Computed( self ) ) THEN
      err_stat = oSRF_Central_Frequency( self )
      IF ( err_stat /= SUCCESS ) THEN
        msg = 'Error occurred computing the central frequency'
        CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
      END IF
    END IF


    ! Get the central frequency
    err_stat = oSRF_GetValue( self, f0 = f0 )
    
    ! Compute the Planck coefficients
    Planck_Coeffs(1) = C1_SCALE_FACTOR*C_1 * ( f0**3 )
    Planck_Coeffs(2) = C2_SCALE_FACTOR*C_2 *   f0

    ! Save the computed Planck coefficients
    err_stat = oSRF_SetValue( self, Planck_Coeffs = planck_coeffs )
    IF ( err_stat /= SUCCESS ) THEN
      msg = 'Error setting the Planck Coefficients'
      CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
    END IF

  END FUNCTION oSRF_Planck_Coefficients


!------------------------------------------------------------------------------
!:sdoc+:
!
! NAME:
!   oSRF_Central_Frequency
!
! PURPOSE:
!   Function to compute the central frequency component of an oSRF_type.
!
! CALLING SEQUENCE:
!   Error_Status = oSRF_Central_Frequency( oSRF )
!
! OBJECT:
!   oSRF:         oSRF structure.
!                 UNITS:      N/A
!                 TYPE:       TYPE(oSRF_type)
!                 DIMENSION:  Scalar
!                 ATTRIBUTES: INTENT(IN OUT)
!
! FUNCTION RESULT:
!   Error_Status: The return value is an integer defining the error status.
!                 The error codes are defined in the Message_Handler module.
!                 If == SUCCESS the integration was successful
!                    == FAILURE an error occurred processing the input
!                 UNITS:      N/A
!                 TYPE:       INTEGER
!                 DIMENSION:  Scalar
!
! SIDE EFFECTS:
!   The central frequency component is set in oSRF and the corresponding
!   bit flag is set to 1.
!
!:sdoc-:
!------------------------------------------------------------------------------

  FUNCTION oSRF_Central_Frequency( self ) RESULT( err_stat )
    ! Arguments
    TYPE(oSRF_type), INTENT(IN OUT):: self
    ! Function result
    INTEGER:: err_stat
    ! Local parameters
    CHARACTER(*), PARAMETER:: ROUTINE_NAME = 'oSRF:: Central_Frequency'
    ! Local variables
    CHARACTER(ML):: msg
    REAL(fp):: f0

    ! Set up
    err_stat = SUCCESS
    ! ...Check object contains something
    IF ( .NOT. oSRF_Associated(self) ) THEN
      err_stat = FAILURE
      msg = 'Input oSRF object is empty'
      CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
    END IF


    ! Compute the oSRF first moment
    err_stat = oSRF_Convolve( self, self%Frequency, f0 )
    IF ( err_stat /= SUCCESS ) THEN
      msg = 'Error convolving oSRF with frequency'
      CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
    END IF


    ! Save the central frequency value
    err_stat = oSRF_SetValue( self, f0 = f0 )
    IF ( err_stat /= SUCCESS ) THEN
      msg = 'Error setting the oSRF central frequency'
      CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
    END IF
    CALL oSRF_Set_F0_Computed( self )

  END FUNCTION oSRF_Central_Frequency


!------------------------------------------------------------------------------
!:sdoc+:
!
! NAME:
!   oSRF_Convolve
!
! PURPOSE:
!   Function to convolve quantities with oSRF.
!
! CALLING SEQUENCE:
!   Error_Status = oSRF_Convolve( oSRF, p, y )
!
! OBJECT:
!   oSRF:          oSRF structure.
!                  UNITS:      N/A
!                  TYPE:       TYPE(oSRF_type)
!                  DIMENSION:  Scalar
!                  ATTRIBUTES: INTENT(IN OUT)
!
! INPUT:
!   p:             Structure array holding quantities
!                  to be convolved.
!                  UNITS:      N/A
!                  TYPE:       TYPE(PtrArr_type)
!                  DIMENSION:  Rank-1
!                  ATTRIBUTES: INTENT(IN)
!
! OUTPUT:
!   y:             Convolved quantity
!                  UNITS:      N/A
!                  TYPE:       REAL(fp)
!                  DIMENSION:  Scalar
!                  ATTRIBUTES: INTENT(OUT)
!
! FUNCTION RESULT:
!   Error_Status:  The return value is an integer defining the error status.
!                  The error codes are defined in the Message_Handler module.
!                  If == SUCCESS the integration was successful
!                     == FAILURE an error occurred processing the input
!                  UNITS:      N/A
!                  TYPE:       INTEGER
!                  DIMENSION:  Scalar
!:sdoc-:
!------------------------------------------------------------------------------

  FUNCTION oSRF_Convolve( self, p, y ) RESULT( err_stat )
    ! Arguments
    TYPE(oSRF_type)  , INTENT(IN OUT):: self
    TYPE(PtrArr_type), INTENT(IN)     :: p(:)
    REAL(fp)         , INTENT(OUT)    :: y
    ! Function result
    INTEGER:: err_stat
    ! Local parameters
    CHARACTER(*), PARAMETER:: ROUTINE_NAME = 'oSRF:: Convolve'
    ! Local variables
    CHARACTER(ML):: msg
    CHARACTER(ML):: alloc_msg
    INTEGER:: alloc_stat
    INTEGER:: n, n_band_points, n_ptrarr_points
    REAL(fp), ALLOCATABLE:: f(:), r(:), c(:)
    REAL(fp):: int_srf, int_band

    ! Setup
    err_stat = SUCCESS
    ! ...Check object contains something
    IF ( .NOT. oSRF_Associated(self) ) THEN
      err_stat = FAILURE
      msg = 'Input oSRF object is empty'
      CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
    END IF
    ! ...Check the band count is the same
    IF ( self%n_Bands /= SIZE(p) ) THEN
      err_stat = FAILURE
      msg = 'Input data does not conform with oSRF'
      CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
    END IF
    ! ...Integrate oSRF if necessary
    IF ( .NOT. oSRF_Is_Integrated( self ) ) THEN
      err_stat = oSRF_Integrate( self )
      IF ( err_stat /= SUCCESS ) THEN
        msg = 'Error integrating oSRF'
        CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
      END IF
    END IF


    ! Sum up band integrals
    y = ZERO
    Band_Loop: DO n = 1, self%n_Bands

      ! Check that passband and array data conform
      ! ...Number of band points
      err_stat = oSRF_GetValue( self, Band = n, n_Band_Points = n_band_points )
      IF ( err_stat /= SUCCESS ) THEN
        WRITE( msg, '("Error occurred retrieving oSRF band#",i0, " number of points")' ) n
        CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
      END IF
      ! ...Number of pointer array element points
      err_stat = PtrArr_GetValue( p(n), n_Points = n_ptrarr_points )
      IF ( err_stat /= SUCCESS ) THEN
        WRITE( msg, '("Error occurred retrieving PtrArr band#",i0, " number of points")' ) n
        CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
      END IF
      ! ...Check the number of points
      IF ( n_band_points /= n_ptrarr_points ) THEN
        err_stat = FAILURE
        WRITE( msg, '("oSRF and PtrArr data have different sizes for band#",i0)' ) n
        WRITE(*,*) n_band_points, n_ptrarr_points
        CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
      END IF

      ! Get band response
      err_stat = oSRF_GetValue( self, Band = n, Frequency = f, Response = r )
      IF ( err_stat /= SUCCESS ) THEN
        WRITE( msg, '("Error occurred retrieving oSRF band#",i0, " data")' ) n
        CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
      END IF

      ! Get data to convolve
      err_stat = PtrArr_GetValue( p(n), Arr = c )
      IF ( err_stat /= SUCCESS ) THEN
        WRITE( msg, '("Error occurred retrieving PtrArr band#",i0, " data")' ) n
        CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
      END IF

      ! Integrate the band
      err_stat = Integral(f, (c*r), int_band)
      IF ( err_stat /= SUCCESS ) THEN
        WRITE( msg, '("Error integrating band#",i0, " response")' ) n
        CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
      END IF

      ! Accumulate
      y = y+int_band

      ! Clean up
      DEALLOCATE( f, r, c, STAT = alloc_stat, ERRMSG = alloc_msg )
      IF ( alloc_stat /= 0 ) THEN
        msg = 'Error deallocating local arrays - '//TRIM(alloc_msg)
        CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
      END IF

    END DO Band_Loop


    ! Normalise the integrated value
    err_stat = oSRF_GetValue( self, Integral = int_srf )
    IF ( err_stat /= SUCCESS ) THEN
      msg = 'Error occurred retrieving the oSRF integral'
      CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
    END IF
    y = y/int_srf

  END FUNCTION oSRF_Convolve


!------------------------------------------------------------------------------
!:sdoc+:
!
! NAME:
!   oSRF_Polychromatic_Coefficients
!
! PURPOSE:
!   Function to compute polychromatic coeffs for an oSRF object.
!
! CALLING SEQUENCE:
!   Error_Status = oSRF_Polychromatic_Coefficients( oSRF )
!
! OBJECT:
!   oSRF:          oSRF structure.
!                  UNITS:      N/A
!                  TYPE:       TYPE(oSRF_type)
!                  DIMENSION:  Scalar
!                  ATTRIBUTES: INTENT(IN OUT)
!
! FUNCTION RESULT:
!   Error_Status: The return value is an integer defining the error status.
!                 The error codes are defined in the Message_Handler module.
!                 If == SUCCESS the integration was successful
!                    == FAILURE an error occurred processing the input
!                 UNITS:      N/A
!                 TYPE:       INTEGER
!                 DIMENSION:  Scalar
!
! SIDE EFFECTS:
!   The polychromatic component of the oSRF object is set.
!
!:sdoc-:
!------------------------------------------------------------------------------

  FUNCTION oSRF_Polychromatic_Coefficients( self ) RESULT( err_stat )
    ! Arguments
    TYPE(oSRF_type), INTENT(IN OUT):: self
    ! Function result
    INTEGER:: err_stat
    ! Local parameters
    CHARACTER(*), PARAMETER:: ROUTINE_NAME = 'oSRF:: Polychromatic_Coefficients'
    ! Local variables
    CHARACTER(ML):: msg
    INTEGER:: i, n, n_bands
    INTEGER, ALLOCATABLE:: n_points(:)
    REAL(fp):: f0
    REAL(fp):: convolved_radiance
    REAL(fp):: x_temperature(N_TEMPS)
    REAL(fp):: y_effective_temperature(N_TEMPS)
    REAL(fp):: y_fit_temperature(N_TEMPS)
    REAL(fp):: polychromatic_coeffs(N_POLY_COEFFS)
    REAL(fp), ALLOCATABLE:: f(:), rad(:)
    TYPE(PtrArr_type):: radiance(self%n_Bands)
    TYPE(oSRF_type)   :: new


    ! Setup
    err_stat = SUCCESS
    ! ...Check object contains something
    IF ( .NOT. oSRF_Associated(self) ) THEN
      err_stat = FAILURE
      msg = 'Input oSRF object is empty'
      CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
    END IF
    ! ...Compute central frequency if necessary
    IF ( .NOT. oSRF_Is_F0_Computed( self ) ) THEN
      err_stat = oSRF_Central_Frequency( self )
      IF ( err_stat /= SUCCESS ) THEN
        msg = 'Error computing central frequency'
        CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
      END IF
    END IF


    ! Copy the input oSRF
    new = self


    ! Generate the monochromatic temperatures
    x_temperature = MIN_TEMP + [(REAL(i-1, fp), i = 1, N_TEMPS)]*D_TEMP


    ! Get some oSRF info for the run
    err_stat = oSRF_GetValue( new, n_Bands = n_bands, n_Points = n_points, f0 = f0 )
    IF ( err_stat /= SUCCESS ) THEN
      msg = 'Error retrieving band/point data from oSRF object'
      CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
    END IF


    ! Allocate the radiance dimensions for each band
    DO n = 1, n_bands
      CALL PtrArr_Create(radiance(n), n_points(n))
      IF ( .NOT. PtrArr_Associated(radiance(n)) ) THEN
        err_stat = FAILURE
        CALL ptrarr_errmsg(radiance(n))
        WRITE(msg, '("Error creating radiance PtrArr for band ",i0)') n
        CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
      END IF
    END DO


    ! Generate the polychromatic temperatures
    Temperature_Loop: DO i = 1, N_TEMPS

      ! Compute monochromatic radiances
      Band_Loop: DO n = 1, n_Bands
        err_stat = oSRF_GetValue( new, Band = n, Frequency = f )
        err_stat = PtrArr_GetValue( radiance(n), Arr = rad )
        CALL Planck_Radiance( f, x_temperature(i), rad )
        err_stat = PtrArr_SetValue( radiance(n), Arr = rad )
      END DO Band_Loop


      ! Convolve the monochromatic radiances
      err_stat = oSRF_Convolve( new, radiance, convolved_radiance )
      IF ( err_stat /= SUCCESS ) THEN
        WRITE( msg, '("Error calculating the convolved radiance at T = ",f5.1, " K.")' ) &
                   x_temperature(i)
        CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
      END IF


      ! Compute the effective temperature
      CALL Planck_Temperature( f0, &
                               convolved_radiance, &
                               y_effective_temperature(i) )

    END DO Temperature_Loop


    ! Fit the mono-and polychromatic temperatures
    err_stat = Least_Squares_Linear_Fit( x_temperature, &
                                         y_effective_temperature, &
                                         polychromatic_coeffs(1), &
                                         polychromatic_coeffs(2), &
                                         yFit = y_fit_temperature  )
    IF ( err_stat /= SUCCESS ) THEN
      msg = 'Error calculating polychromatic coefficients'
      CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
    END IF


    ! Save the polychromatic coefficients and associated temperature data
    err_stat = oSRF_SetValue( &
      self, &
      Polychromatic_Coeffs  = polychromatic_coeffs, &
      Temperature           = x_temperature, &
      Effective_Temperature = y_effective_temperature, &
      Fit_Temperature       = y_fit_temperature )
    IF ( err_stat /= SUCCESS ) THEN
      msg = 'Error occurred saving the polychromatic coefficients'
      CALL Display_Message( ROUTINE_NAME, msg, err_stat ); RETURN
     END IF

  END FUNCTION oSRF_Polychromatic_Coefficients


!--------------------------------------------------------------------------------
!:sdoc+:
!
! NAME:
!   oSRF_DefineVersion
!
! PURPOSE:
!   Subroutine to return the module version information.
!
! CALLING SEQUENCE:
!   CALL oSRF_DefineVersion( Id )
!
! OUTPUTS:
!   Id:    Character string containing the version Id information
!          for the module.
!          UNITS:      N/A
!          TYPE:       CHARACTER(*)
!          DIMENSION:  Scalar
!          ATTRIBUTES: INTENT(OUT)
!
!:sdoc-:
!--------------------------------------------------------------------------------

  SUBROUTINE oSRF_DefineVersion( Id )
    CHARACTER(*), INTENT(OUT):: Id
    Id = MODULE_VERSION_ID
  END SUBROUTINE oSRF_DefineVersion


!--------------------------------------------------------------------------------
!:sdoc+:
!
! NAME:
!   oSRF_Compare
!
! PURPOSE:
!   Function to test the equality of two oSRF objects.
!
!   This procedure is basically a copy of the oSRF_Equal function
!   but non-elemental to allow for informational output when a difference
!   is found between the two structures.
!
!   Used for debugging only.
!
! CALLING SEQUENCE:
!   is_equal = oSRF_Compare( x, y )
!
! OBJECTS:
!   x, y:          Two oSRF objects to be compared.
!                  UNITS:      N/A
!                  TYPE:       TYPE(oSRF_type)
!                  DIMENSION:  Scalar
!                  ATTRIBUTES: INTENT(IN)
!
! FUNCTION RESULT:
!   is_equal:      Logical value indicating whether the inputs are equal.
!                  UNITS:      N/A
!                  TYPE:       LOGICAL
!                  DIMENSION:  Scalar
!
!:sdoc-:
!--------------------------------------------------------------------------------

  FUNCTION oSRF_Compare( x, y ) RESULT( is_equal )
    ! Arguments
    TYPE(oSRF_type), INTENT(IN):: x, y
    LOGICAL:: is_equal
    ! Local parameters
    CHARACTER(*), PARAMETER:: ROUTINE_NAME = 'oSRF:: Compare'
    ! Local variable
    CHARACTER(ML):: msg

    ! Set up
    is_equal = .FALSE.

    ! Check the object association status
    IF ( oSRF_Associated(x) .NEQV. oSRF_Associated(y) ) THEN
      msg = 'Object association statuses are different'
      CALL Display_Message(ROUTINE_NAME, msg, FAILURE); RETURN
    END IF

    ! Check scalar contents
    ! ...Release/version info
    IF ( (x%Release /= y%Release) .OR. &
         (x%Version /= y%Version) ) THEN
      msg = 'Object releases/versions are different'
      CALL Display_Message(ROUTINE_NAME, msg, FAILURE); RETURN
    END IF
    ! ...SensorInfo
    IF ( (x%WMO_Satellite_Id /= y%WMO_Satellite_Id) .OR. &
         (x%WMO_Sensor_Id    /= y%WMO_Sensor_Id   ) .OR. &
         (x%Sensor_Type      /= y%Sensor_Type     ) .OR. &
         (x%Channel          /= y%Channel         ) ) THEN
      msg = 'Object SensorInfo components are different'
      CALL Display_Message(ROUTINE_NAME, msg, FAILURE); RETURN
    END IF
    ! ...Band and flag components
    IF ( x%n_Bands /= y%n_Bands ) THEN
      msg = 'Object band numbers are different'
      CALL Display_Message(ROUTINE_NAME, msg, FAILURE); RETURN
    END IF
    IF ( x%Flags /= y%Flags ) THEN
      msg = 'Object flag settings are different'
      CALL Display_Message(ROUTINE_NAME, msg, FAILURE); RETURN
    END IF
    ! ...Info derived from data
    IF ( .NOT. (x%Integral .EqualTo. y%Integral) ) THEN
      msg = 'Object integrals are different'
      CALL Display_Message(ROUTINE_NAME, msg, FAILURE); RETURN
    END IF
    IF ( .NOT. (x%f0 .EqualTo. y%f0) ) THEN
      msg = 'Object central frequencies are different'
      CALL Display_Message(ROUTINE_NAME, msg, FAILURE); RETURN
    END IF
    
    
    ! Check array contents
    IF ( oSRF_Associated(x) .AND. oSRF_Associated(y) ) THEN
      IF ( .NOT. ALL(x%Planck_Coeffs .EqualTo. y%Planck_Coeffs) ) THEN
        msg = 'Object Planck coefficients are different'
        CALL Display_Message(ROUTINE_NAME, msg, FAILURE); RETURN
      END IF
      IF ( .NOT. ALL(x%Polychromatic_Coeffs .EqualTo. y%Polychromatic_Coeffs) ) THEN
        msg = 'Object Polychromatic correction coefficients are different'
        CALL Display_Message(ROUTINE_NAME, msg, FAILURE); RETURN
      END IF
      IF ( ANY(x%n_Points /= y%n_Points) ) THEN
        msg = 'Object number of passband points are different'
        CALL Display_Message(ROUTINE_NAME, msg, FAILURE); RETURN
      END IF
      IF ( .NOT. ALL(x%f1 .EqualTo. y%f1) ) THEN
        msg = 'Object begin frequencies are different'
        CALL Display_Message(ROUTINE_NAME, msg, FAILURE); RETURN
      END IF
      IF ( .NOT. ALL(x%f2 .EqualTo. y%f2) ) THEN
        msg = 'Object end frequencies are different'
        CALL Display_Message(ROUTINE_NAME, msg, FAILURE); RETURN
      END IF
      IF ( .NOT. ALL(x%Frequency == y%Frequency) ) THEN
        msg = 'Object band frequencies are different'
        CALL Display_Message(ROUTINE_NAME, msg, FAILURE); RETURN
      END IF
      IF ( .NOT. ALL(x%Response == y%Response) ) THEN
        msg = 'Object band responses are different'
        CALL Display_Message(ROUTINE_NAME, msg, FAILURE); RETURN
      END IF
    END IF
    
    
    ! If we get here, then...
    is_equal = .TRUE.

  END FUNCTION oSRF_Compare


!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------
! NOTE: The flag check, set, and clear procedures in this include file were
!       generated automatically using the
!         gen_flag_procedures.rb
!       script. Modify at your own risk!
  INCLUDE 'oSRF_Flag_Procedures.inc'
!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------
  
!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------
! NOTE: The sensor check, set, and clear procedures in this include file were
!       generated automatically using the
!         gen_sensor_procedures.rb
!       script. Modify at your own risk!
  INCLUDE 'oSRF_Sensor_Procedures.inc'
!--------------------------------------------------------------------------------
!--------------------------------------------------------------------------------


!##################################################################################
!##################################################################################
!##                                                                              ##
!##                          ## PRIVATE MODULE ROUTINES ##                       ##
!##                                                                              ##
!##################################################################################
!##################################################################################

!--------------------------------------------------------------------------------
!
! NAME:
!   oSRF_Equal
!
! PURPOSE:
!   Elemental function to test the equality of two oSRF objects.
!   Used in OPERATOR(==) interface block.
!
! CALLING SEQUENCE:
!   is_equal = oSRF_Equal( x, y )
!
!     or
!
!   IF ( x == y ) THEN
!     ...
!   END IF
!
! OBJECTS:
!   x, y:          Two oSRF objects to be compared.
!                  UNITS:      N/A
!                  TYPE:       TYPE(oSRF_type)
!                  DIMENSION:  Scalar
!                  ATTRIBUTES: INTENT(IN)
!
! FUNCTION RESULT:
!   is_equal:      Logical value indicating whether the inputs are equal.
!                  UNITS:      N/A
!                  TYPE:       LOGICAL
!                  DIMENSION:  Scalar
!
!--------------------------------------------------------------------------------

  ELEMENTAL FUNCTION oSRF_Equal( x, y ) RESULT( is_equal )
    TYPE(oSRF_type), INTENT(IN)  :: x, y
    LOGICAL:: is_equal

    ! Set up
    is_equal = .FALSE.

    ! Check the structure association status
    IF ( (.NOT. oSRF_Associated(x)) .OR. &
         (.NOT. oSRF_Associated(y))      ) RETURN

    ! Check contents
    ! ...Scalar Integers/characters
    IF ( (x%Version          /= y%Version         ) .OR. &
         (x%n_Bands          /= y%n_Bands         ) .OR. &
         (x%WMO_Satellite_Id /= y%WMO_Satellite_Id) .OR. &
         (x%WMO_Sensor_Id    /= y%WMO_Sensor_Id   ) .OR. &
         (x%Sensor_Type      /= y%Sensor_Type     ) .OR. &
         (x%Channel          /= y%Channel         ) .OR. &
         (x%Flags            /= y%Flags           ) ) RETURN
    ! ...Reals
    IF ( (x%Integral .EqualTo. y%Integral ) .AND. &
         (x%f0       .EqualTo. y%f0       ) .AND. &
         ALL(x%Planck_Coeffs        .EqualTo. y%Planck_Coeffs       ) .AND. &
         ALL(x%Polychromatic_Coeffs .EqualTo. y%Polychromatic_Coeffs) .AND. &
         ALL(x%n_Points                ==     y%n_Points            ) .AND. &
         ALL(x%Planck_Coeffs        .EqualTo. y%Planck_Coeffs       ) .AND. &
         ALL(x%Planck_Coeffs        .EqualTo. y%Planck_Coeffs       ) .AND. &
         ALL(x%f1                   .EqualTo. y%f1                  ) .AND. &
         ALL(x%f2                   .EqualTo. y%f2                  ) ) is_equal = .TRUE.
    ! ...Structures
    is_equal = is_equal .AND. &
               ALL(x%Frequency == y%Frequency) .AND. &
               ALL(x%Response  == y%Response )

  END FUNCTION oSRF_Equal


!--------------------------------------------------------------------------------
!
! NAME:
!   Least_Squares_Linear_Fit
!
! PURPOSE:
!   Function to perform a least squares linear fit on the input
!   polychromatic and monochromatic temperature data.
!
! CALLING SEQUENCE:
!   Error_Status = Least_Squares_Linear_Fit( x, y,        &  ! Input
!                                            a, b,        &  ! Output
!                                            yFit = yFit, &  ! Optional output
!                                            SSE  = SSE,  &  ! Optional output
!                                            MSE  = MSE   )  ! Optional output
!
! INPUT ARGUMENTS:
!   x:               Input ordinate data on which to perform the fit
!                      y = a+bx
!                    Corresponds to the true temperature.
!                    UNITS:      Kelvin (K)
!                    TYPE:       REAL(fp)
!                    DIMENSION:  Rank-1
!                    ATTRIBUTES: INTENT( IN )
!
!   y:               Input coordinate data on which to perform the fit
!                      y = a+bx
!                    Corresponds to the effective temperature due to
!                    polychromaticity.
!                    UNITS:      Kelvin (K)
!                    TYPE:       REAL(fp)
!                    DIMENSION:  Rank-1 (Same size as x)
!                    ATTRIBUTES: INTENT( IN )
!
! OUTPUT ARGUMENTS:
!   a:               Offset coefficient that satisfies the fit criteria
!                    for the relationship
!                      y = a+bx
!                    UNITS:      Kelvin (K)
!                    TYPE:       REAL(fp)
!                    DIMENSION:  Scalar
!                    ATTRIBUTES: INTENT( OUT )
!
!   b:               Slope coefficient that satisfies the fit criteria
!                    for the relationship
!                      y = a+bx
!                    UNITS:      Kelvin/Kelvin (K/K)
!                    TYPE:       REAL(fp)
!                    DIMENSION:  Scalar
!                    ATTRIBUTES: INTENT( OUT )
!
! OPTIONAL OUTPUT ARGUMENTS:
!   yFit:            Predicted coordinate (effective temperature) data, 
!                      yFit = a+bx
!                    UNITS:      Kelvin (K)
!                    TYPE:       REAL(fp)
!                    DIMENSION:  Rank-1 (Same size as y)
!                    ATTRIBUTES: OPTIONAL, INTENT( OUT )
!
!   SSE:             The residual sum of the squares of the fit to the
!                    input data, 
!                             __  N
!                            \                    2
!                      SSE =  > ( Y(i) - YFit(i) )
!                            /__
!                                i = 1
!
!                    UNITS:      Kelvin^2 (K^2)
!                    TYPE:       REAL(fp)
!                    DIMENSION:  Scalar
!                    ATTRIBUTES: OPTIONAL, INTENT( OUT )
!
!   MSE:             The residual mean square of the fit to the
!                    input data, 
!
!                             SSE
!                      MSE = -----
!                             N-2
!
!                    where N == number of input data points
!
!                    UNITS:      Kelvin^2 (K^2)
!                    TYPE:       REAL(fp)
!                    DIMENSION:  Scalar
!                    ATTRIBUTES: OPTIONAL, INTENT( OUT )
!
! FUNCTION RESULT:
!   Error_Status:    The return value is an integer defining the
!                    error status. The error codes are defined in
!                    the ERROR_HANDLER module.
!                    If == SUCCESS the regression fit was successful.
!                       == FAILURE  an error occurred
!                    UNITS:      N/A
!                    TYPE:       INTEGER
!                    DIMENSION:  Scalar
!
!--------------------------------------------------------------------------------

  FUNCTION Least_Squares_Linear_Fit( x, y,         &  ! Input
                                     a, b,         &  ! Output
                                     yFit,         &  ! Optional output
                                     SSE,          &  ! Optional output
                                     MSE         ) &  ! Optional output
                                   RESULT( Error_Status )
    ! Arguments
    REAL(fp),           INTENT(IN)  :: x(:)
    REAL(fp),           INTENT(IN)  :: y(:)
    REAL(fp),           INTENT(OUT):: a
    REAL(fp),           INTENT(OUT):: b
    REAL(fp), OPTIONAL, INTENT(OUT):: yFit(:)
    REAL(fp), OPTIONAL, INTENT(OUT):: SSE
    REAL(fp), OPTIONAL, INTENT(OUT):: MSE
    ! Function result
    INTEGER:: Error_Status
    ! Local parameters
    CHARACTER(*), PARAMETER:: ROUTINE_NAME = 'Least_Squares_Linear_Fit'
    REAL(fp),     PARAMETER:: TOLERANCE = EPSILON(1.0_fp)
    ! Local variables
    CHARACTER(ML):: msg
    INTEGER:: n
    REAL(fp):: xAverage
    REAL(fp):: yAverage
    REAL(fp):: sum_dx2
    REAL(fp):: yCalculated(SIZE(y))
    REAL(fp):: Residual_Sum_of_Squares
    REAL(fp):: Residual_Mean_Square


    ! Set up
    Error_Status = SUCCESS
    ! ...Check input
    n = SIZE(x)
    IF ( n < 3 ) THEN
      Error_Status = FAILURE
      msg = 'Input data must be at least 3 points'
      CALL Display_Message( ROUTINE_NAME, msg, Error_Status ); RETURN
    END IF
    IF ( SIZE(y) /= n ) THEN
      Error_Status = FAILURE
      msg = 'Sizes of input X, Y arguments are inconsistent'
      CALL Display_Message( ROUTINE_NAME, msg, Error_Status ); RETURN
    END IF
    IF ( PRESENT(yFit) ) THEN
      IF ( SIZE(yFit) /= n ) THEN
        Error_Status = FAILURE
        msg = 'Size of output YFIT argument is inconsistent'
        CALL Display_Message( ROUTINE_NAME, msg, Error_Status ); RETURN
      END IF
    END IF


    ! Calculate averages
    xAverage = SUM(x) / REAL(n, fp)
    yAverage = SUM(y) / REAL(n, fp)


    ! Calculate the sums of the square of the mean difference for X
    sum_dx2 = SUM(( x-xAverage )**2)
    IF ( sum_dx2 < TOLERANCE ) THEN
      Error_Status = FAILURE
      msg = 'Sum of the squares of mean difference for X is zero'
      CALL Display_Message( ROUTINE_NAME, msg, Error_Status ); RETURN
    END IF


    ! Calculate coefficients
    b = SUM(( x-xAverage )*( y-yAverage )) / sum_dx2
    a = yAverage - ( b*xAverage )


    ! Calculate the regression Y values
    yCalculated = a + ( b*x )
    Residual_Sum_of_Squares = SUM(( y-yCalculated )**2)
    Residual_Mean_Square    = Residual_Sum_of_Squares/REAL(n-2, fp)


    ! Assign optional arguments
    IF ( PRESENT(yFit) ) yFit = yCalculated
    IF ( PRESENT(SSE)  ) SSE  = Residual_Sum_of_Squares
    IF ( PRESENT(MSE)  ) MSE  = Residual_Mean_Square

  END FUNCTION Least_Squares_Linear_Fit

END MODULE oSRF_Define


